
import React, { useState, useEffect, useCallback, useMemo, useRef } from 'react';
// ‚îÄ‚îÄ‚îÄ Data Registry (300 mechanics from pzo-web/src/data/) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
import MECHANICS_DATA from './data/mechanics_core.json';
import ML_DATA        from './data/ml_core.json';

import CardHand, { Card, DeckType } from './components/CardHand';
import GameBoard from './components/GameBoard';
import ShieldIcons from './components/ShieldIcons';
import MomentFlash from './components/MomentFlash';
import ProofCard from './components/ProofCard';
import BankruptcyScreen from './components/BankruptcyScreen';

const STARTING_CASH = 50_000;
const STARTING_INCOME = 3_500;
const STARTING_EXPENSES = 4_200;
const RUN_TICKS = 720;
const TICK_MS = 1000;
const MONTH_TICKS = 12;
const DRAW_TICKS = 24;
const MAX_HAND = 5;
const MAX_LOG = 80;
const MAX_EQUITY_POINTS = 120;

type Screen = 'landing' | 'run' | 'result' | 'bankrupt';
type MechanicKind = 'core' | 'ml';
type MechanicFamily =
  | 'replay'
  | 'economy'
  | 'risk'
  | 'market'
  | 'cards'
  | 'progression'
  | 'social'
  | 'telemetry'
  | 'pvp'
  | 'season'
  | 'ai'
  | 'anti_cheat'
  | 'narrative'
  | 'ops'
  | 'unknown';

type MarketRegime = 'Stable' | 'Expansion' | 'Compression' | 'Panic' | 'Euphoria';
type RunMode = 'solo' | 'asymmetric-pvp' | 'co-op' | 'ghost';
type MechanicsFilter = 'all' | 'core' | 'ml';

type MechanicDef = {
  id: string;
  title: string;
  kind: MechanicKind;
  family: MechanicFamily;
  pairId?: string;
  weight: number;
  keywordTags: string[];
};

type MechanicRuntimeState = {
  enabled: boolean;
  activations: number;
  lastTick: number;
  heat: number;
  confidence: number;
  signal: number;
};

type IntelligenceState = {
  alpha: number;
  risk: number;
  volatility: number;
  antiCheat: number;
  personalization: number;
  rewardFit: number;
  recommendationPower: number;
  churnRisk: number;
  momentum: number;
};

type SeasonState = {
  xp: number;
  passTier: number;
  dominionControl: number;
  nodePressure: number;
  winStreak: number;
  battlePassLevel: number;
  rewardsPending: number;
};

type TelemetryEnvelopeV2 = {
  tick: number;
  type: string;
  payload: Record<string, number | string | boolean | null>;
};

type MacroEvent = {
  id: string;
  label: string;
  apply: () => void;
};

// ‚îÄ‚îÄ‚îÄ Core Mechanic Titles (150) ‚Äî loaded from mechanics_core.json ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const CORE_MECHANIC_TITLES: ReadonlyArray<readonly [string, string]> =
  (MECHANICS_DATA as Array<{ mechanic_id: string; title: string }>).map(
    (m) => [m.mechanic_id, m.title] as const
  );


// ‚îÄ‚îÄ‚îÄ ML Mechanic Titles (150) ‚Äî loaded from ml_core.json ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const ML_MECHANIC_TITLES: ReadonlyArray<readonly [string, string]> =
  (ML_DATA as Array<{ mechanic_id: string; title: string }>).map(
    (m) => [m.mechanic_id, m.title] as const
  );



function clamp(n: number, min: number, max: number) {
  return Math.max(min, Math.min(max, n));
}

function hashString(input: string): number {
  let h = 2166136261;
  for (let i = 0; i < input.length; i++) {
    h ^= input.charCodeAt(i);
    h = Math.imul(h, 16777619);
  }
  return h >>> 0;
}

function mulberry32(seed: number) {
  let t = seed >>> 0;
  return function rng() {
    t += 0x6D2B79F5;
    let x = t;
    x = Math.imul(x ^ (x >>> 15), x | 1);
    x ^= x + Math.imul(x ^ (x >>> 7), x | 61);
    return ((x ^ (x >>> 14)) >>> 0) / 4294967296;
  };
}

function randomSeed(): number {
  try {
    const arr = new Uint32Array(1);
    window.crypto.getRandomValues(arr);
    return arr[0] || Math.floor(Math.random() * 2 ** 32);
  } catch {
    return Math.floor(Math.random() * 2 ** 32);
  }
}

function fmtMoney(n: number) {
  const sign = n < 0 ? '-' : '';
  const v = Math.abs(n);
  if (v >= 1_000_000_000) return `${sign}$${(v / 1e9).toFixed(2)}B`;
  if (v >= 1_000_000) return `${sign}$${(v / 1e6).toFixed(2)}M`;
  if (v >= 1_000) return `${sign}$${(v / 1e3).toFixed(1)}K`;
  return `${sign}$${Math.round(v).toLocaleString()}`;
}

function fmtPct01(n: number) {
  return `${Math.round(n * 100)}%`;
}

function idNum(id: string) {
  const m = id.match(/M(\d+)/i);
  return m ? Number(m[1]) : 0;
}

function keywordTagsFromTitle(title: string): string[] {
  return title
    .toLowerCase()
    .replace(/[^a-z0-9\s-]/g, ' ')
    .split(/\s+/)
    .filter(Boolean)
    .slice(0, 8);
}

function inferFamily(id: string, title: string, kind: MechanicKind): MechanicFamily {
  const t = title.toLowerCase();

  if (t.includes('anti-cheat') || t.includes('fraud') || t.includes('abuse') || t.includes('integrity')) return 'anti_cheat';
  if (t.includes('pvp') || t.includes('matchmaking') || t.includes('duel') || t.includes('opponent')) return 'pvp';
  if (t.includes('season') || t.includes('battle pass') || t.includes('dominion') || t.includes('node') || t.includes('founding era')) return 'season';
  if (t.includes('telemetry') || t.includes('analytics') || t.includes('event bus') || t.includes('observability') || t.includes('verifiable')) return 'telemetry';
  if (t.includes('narrative') || t.includes('story') || t.includes('codex') || t.includes('lore')) return 'narrative';
  if (t.includes('card') || t.includes('deck') || t.includes('draw') || t.includes('hand') || t.includes('shuffle')) return 'cards';
  if (t.includes('market') || t.includes('price') || t.includes('volatility') || t.includes('scarcity') || t.includes('counterparty')) return 'market';
  if (t.includes('risk') || t.includes('fubar') || t.includes('loss') || t.includes('crash') || t.includes('bankruptcy') || t.includes('collapse')) return 'risk';
  if (t.includes('economy') || t.includes('income') || t.includes('cash') || t.includes('yield') || t.includes('roi') || t.includes('monetiz') || t.includes('pricing')) return 'economy';
  if (t.includes('quest') || t.includes('progress') || t.includes('unlock') || t.includes('achievement') || t.includes('tutorial')) return 'progression';
  if (t.includes('social') || t.includes('guild') || t.includes('party') || t.includes('friend') || t.includes('spectator')) return 'social';
  if (t.includes('replay') || t.includes('deterministic') || t.includes('seed')) return 'replay';
  if (t.includes('ops') || t.includes('orchestrator') || t.includes('router') || t.includes('runtime')) return 'ops';

  const n = idNum(id);
  if (kind === 'ml') {
    if (n <= 25) return 'ai';
    if (n <= 50) return 'economy';
    if (n <= 75) return 'risk';
    if (n <= 100) return 'market';
    if (n <= 125) return 'season';
    return 'anti_cheat';
  }
  if (n <= 20) return 'replay';
  if (n <= 40) return 'cards';
  if (n <= 60) return 'economy';
  if (n <= 80) return 'market';
  if (n <= 100) return 'progression';
  if (n <= 120) return 'season';
  if (n <= 135) return 'pvp';
  return 'telemetry';
}

function weightForMechanic(id: string, kind: MechanicKind, family: MechanicFamily): number {
  const n = idNum(id);
  let base = kind === 'ml' ? 0.45 : 0.65;
  if (family === 'economy') base += 0.12;
  if (family === 'risk' || family === 'anti_cheat') base += 0.08;
  if (family === 'season' || family === 'pvp') base += 0.05;
  base += (n % 7) * 0.01;
  return Number(base.toFixed(2));
}

function buildCatalog(): MechanicDef[] {
  const core = CORE_MECHANIC_TITLES.map(([id, title]) => {
    const family = inferFamily(id, title, 'core');
    return {
      id,
      title,
      kind: 'core' as const,
      family,
      pairId: `${id}a`,
      weight: weightForMechanic(id, 'core', family),
      keywordTags: keywordTagsFromTitle(title),
    };
  });

  const ml = ML_MECHANIC_TITLES.map(([id, title]) => {
    const family = inferFamily(id, title, 'ml');
    const pairId = id.endsWith('a') ? id.slice(0, -1) : undefined;
    return {
      id,
      title,
      kind: 'ml' as const,
      family,
      pairId,
      weight: weightForMechanic(id, 'ml', family),
      keywordTags: keywordTagsFromTitle(title),
    };
  });

  return [...core, ...ml];
}

function initRuntime(catalog: MechanicDef[]): Record<string, MechanicRuntimeState> {
  const out: Record<string, MechanicRuntimeState> = {};
  for (const def of catalog) {
    out[def.id] = {
      enabled: true,
      activations: 0,
      lastTick: -1,
      heat: 0,
      confidence: def.kind === 'ml' ? 0.5 : 0.6,
      signal: 0,
    };
  }
  return out;
}

function decayRuntime(runtime: Record<string, MechanicRuntimeState>) {
  const next: Record<string, MechanicRuntimeState> = {};
  for (const [id, st] of Object.entries(runtime)) {
    next[id] = {
      ...st,
      heat: Math.max(0, st.heat - 0.012),
      confidence: clamp(st.confidence - 0.001, 0.08, 0.99),
      signal: st.signal * 0.93,
    };
  }
  return next;
}

// ‚îÄ‚îÄ‚îÄ Seed Cards + Generated Mechanic Cards ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const SEED_DECK: Card[] = [
  {
    id: 'opp-001', name: 'Single Family Rental', type: 'OPPORTUNITY' as DeckType,
    subtype: 'Real Estate', description: 'Cash-flowing rental property in emerging market.',
    cost: 25000, leverage: 100000, downPayment: 25000,
    cashflowMonthly: 400, roiPct: 19, cashImpact: null, turnsLost: null, value: null,
    energyCost: 25000, synergies: [],
  },
  {
    id: 'ipa-001', name: 'Dividend Stock Bundle', type: 'IPA' as DeckType,
    subtype: 'Equities', description: 'High-yield dividend portfolio. Passive income every tick.',
    cost: 10000, leverage: null, downPayment: null,
    cashflowMonthly: 120, roiPct: 14, cashImpact: null, turnsLost: null, value: null,
    energyCost: 10000, synergies: [],
  },
  {
    id: 'fubar-001', name: 'Market Crash Wave', type: 'FUBAR' as DeckType,
    subtype: 'Macro', description: 'Systemic shock hits portfolio value.',
    cost: null, leverage: null, downPayment: null,
    cashflowMonthly: null, roiPct: null, cashImpact: -7500, turnsLost: null, value: null,
    energyCost: 0, synergies: [],
  },
  {
    id: 'opp-002', name: 'Digital Business', type: 'OPPORTUNITY' as DeckType,
    subtype: 'Business', description: 'SaaS micro-business generating recurring revenue.',
    cost: 15000, leverage: null, downPayment: null,
    cashflowMonthly: 800, roiPct: 64, cashImpact: null, turnsLost: null, value: null,
    energyCost: 15000, synergies: [],
  },
  {
    id: 'miss-001', name: 'Analysis Paralysis', type: 'MISSED_OPPORTUNITY' as DeckType,
    subtype: 'Behavior', description: 'You hesitated. The deal closed without you.',
    cost: null, leverage: null, downPayment: null,
    cashflowMonthly: null, roiPct: null, cashImpact: null, turnsLost: 3, value: null,
    energyCost: 0, synergies: [],
  },
  {
    id: 'priv-001', name: 'Inherited Network', type: 'PRIVILEGED' as DeckType,
    subtype: 'Access', description: 'Off-market deal from a warm intro. Unfair advantage activated.',
    cost: null, leverage: null, downPayment: null,
    cashflowMonthly: null, roiPct: null, cashImpact: null, turnsLost: null, value: 20000,
    energyCost: 0, synergies: [],
  },
];

function generatedCardTypeFromFamily(family: MechanicFamily, h: number): DeckType {
  if (family === 'risk' || family === 'anti_cheat') return 'FUBAR' as DeckType;
  if (family === 'cards') return (h % 4 === 0 ? 'IPA' : 'OPPORTUNITY') as DeckType;
  if (family === 'economy' || family === 'progression') return (h % 3 === 0 ? 'IPA' : 'OPPORTUNITY') as DeckType;
  if (family === 'season' || family === 'social' || family === 'pvp') return (h % 5 === 0 ? 'PRIVILEGED' : 'OPPORTUNITY') as DeckType;
  if (family === 'market') return (h % 4 === 0 ? 'FUBAR' : 'OPPORTUNITY') as DeckType;
  if (family === 'replay' || family === 'telemetry' || family === 'ops' || family === 'narrative') return (h % 2 === 0 ? 'SO' : 'IPA') as DeckType;
  return (h % 6 === 0 ? 'MISSED_OPPORTUNITY' : 'OPPORTUNITY') as DeckType;
}

function subtypeFromFamily(family: MechanicFamily): string {
  switch (family) {
    case 'economy': return 'Capital';
    case 'risk': return 'Hazard';
    case 'market': return 'Macro';
    case 'cards': return 'Deck Engine';
    case 'progression': return 'Meta';
    case 'social': return 'Network';
    case 'telemetry': return 'Observability';
    case 'pvp': return 'Arena';
    case 'season': return 'Dominion';
    case 'ai': return 'Inference';
    case 'anti_cheat': return 'Integrity';
    case 'narrative': return 'Lore';
    case 'ops': return 'Runtime';
    case 'replay': return 'Determinism';
    default: return 'System';
  }
}

function buildGeneratedDeck(coreCatalog: MechanicDef[]): Card[] {
  const generated = coreCatalog.map((def) => {
    const h = hashString(def.id + def.title);
    const type = generatedCardTypeFromFamily(def.family, h);
    const baseCost = 2_500 + (h % 11) * 750;
    const incomeBoost = 80 + (h % 9) * 40;
    const roiPct = 8 + (h % 18);
    const isHazard = type === ('FUBAR' as DeckType);
    const isMissed = type === ('MISSED_OPPORTUNITY' as DeckType);
    const isPrivilege = type === ('PRIVILEGED' as DeckType);
    const isObstacle = type === ('SO' as DeckType);

    const labelTail = def.title.replace(/^M\d+[a-z]?\s*[-‚Äî:]\s*/i, '');
    const descKind = def.kind === 'core' ? 'Core mechanic' : 'ML companion';

    return {
      id: `gen-${def.id.toLowerCase()}`,
      name: `${def.id} ‚Ä¢ ${labelTail}`,
      type,
      subtype: subtypeFromFamily(def.family),
      description: `${descKind} wired into runtime registry (${def.family}).`,
      cost: isHazard || isMissed || isPrivilege || isObstacle ? null : baseCost,
      leverage: def.family === 'economy' ? baseCost * 3 : null,
      downPayment: def.family === 'economy' ? Math.round(baseCost * 0.25) : null,
      cashflowMonthly: isHazard || isMissed || isPrivilege || isObstacle ? null : incomeBoost,
      roiPct: isHazard || isMissed ? null : roiPct,
      cashImpact: isHazard ? -(1_200 + (h % 7) * 900) : null,
      turnsLost: isMissed ? 1 + (h % 3) : null,
      value: isPrivilege ? 2_500 + (h % 9) * 1_750 : def.family === 'season' ? 1_500 + (h % 7) * 900 : null,
      energyCost: isHazard || isMissed || isPrivilege || isObstacle ? 0 : baseCost,
      synergies: [],
    } as Card;
  });

  return [...SEED_DECK, ...generated];
}

function drawRandomCards(pool: Card[], n: number, rng: () => number): Card[] {
  const out: Card[] = [];
  for (let i = 0; i < n; i++) {
    const c = pool[Math.floor(rng() * pool.length)];
    if (!c) continue;
    out.push({ ...c, id: `${c.id}-${Math.floor(rng() * 1e9).toString(36)}` });
  }
  return out;
}

// ‚îÄ‚îÄ‚îÄ UI Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function Sparkline({ data }: { data: number[] }) {
  if (data.length < 2) return null;
  const w = 200;
  const h = 48;
  const min = Math.min(...data);
  const max = Math.max(...data);
  const range = max - min || 1;
  const pts = data
    .map((v, i) => {
      const x = (i / (data.length - 1)) * w;
      const y = h - ((v - min) / range) * h;
      return `${x},${y}`;
    })
    .join(' ');
  const positive = data[data.length - 1] >= data[0];
  return (
    <svg width={w} height={h} className="overflow-visible">
      <polyline points={pts} fill="none" stroke={positive ? '#10b981' : '#ef4444'} strokeWidth={1.5} />
    </svg>
  );
}

function HUD(props: {
  cash: number;
  income: number;
  expenses: number;
  tick: number;
  shields: number;
  netWorth: number;
  equityHistory: number[];
  regime: MarketRegime;
  intelligence: IntelligenceState;
  season: SeasonState;
  runMode: RunMode;
  activeMechanics: number;
  telemetryCount: number;
  freezeTicks: number;
}) {
  const {
    cash, income, expenses, tick, shields, netWorth, equityHistory, regime,
    intelligence, season, runMode, activeMechanics, telemetryCount, freezeTicks,
  } = props;
  const cashflow = income - expenses;
  const pct = Math.round((tick / RUN_TICKS) * 100);

  return (
    <div className="bg-zinc-900 border-b border-zinc-800 px-4 py-2 flex items-center gap-4 flex-wrap text-xs">
      <Metric label="Cash" value={fmtMoney(cash)} danger={cash < 5000} />
      <Metric label="Net Worth" value={fmtMoney(netWorth)} />
      <Metric label="Cashflow/mo" value={`${cashflow >= 0 ? '+' : ''}${fmtMoney(cashflow)}`} success={cashflow >= 0} danger={cashflow < 0} />
      <Metric label="Income/mo" value={fmtMoney(income)} success />
      <Metric label="Expenses/mo" value={fmtMoney(expenses)} danger />
      <Metric label="Regime" value={regime} />
      <Metric label="Mode" value={runMode} />
      <Metric label="AI Alpha" value={fmtPct01(intelligence.alpha)} />
      <Metric label="Risk" value={fmtPct01(intelligence.risk)} />
      <Metric label="Pass" value={`T${season.passTier}`} />
      <Metric label="Dominion" value={`${season.dominionControl}`} />
      <Metric label="Mechs" value={`${activeMechanics}/300`} />
      <Metric label="Events" value={`${telemetryCount}`} />
      <Metric label="Freeze" value={freezeTicks > 0 ? `${freezeTicks}t` : '‚Äî'} />
      <div className="flex flex-col">
        <span className="text-zinc-500 uppercase tracking-wide">Shields</span>
        <span className="text-yellow-400 font-mono">{Array(shields).fill('üõ°Ô∏è').join(' ') || '‚Äî'}</span>
      </div>
      <div className="flex flex-col flex-1 min-w-[220px]">
        <div className="flex justify-between mb-0.5">
          <span className="text-zinc-500 uppercase tracking-wide">Run Progress</span>
          <span className="text-zinc-400">{pct}%</span>
        </div>
        <div className="h-1.5 bg-zinc-800 rounded-full">
          <div className="h-full bg-indigo-500 rounded-full transition-all" style={{ width: `${pct}%` }} />
        </div>
      </div>
      <div><Sparkline data={equityHistory} /></div>
    </div>
  );
}

function Metric({
  label,
  value,
  success = false,
  danger = false,
}: {
  label: string;
  value: string;
  success?: boolean;
  danger?: boolean;
}) {
  const color = danger ? 'text-red-400' : success ? 'text-emerald-400' : 'text-white';
  return (
    <div className="flex flex-col min-w-[72px]">
      <span className="text-zinc-500 uppercase tracking-wide">{label}</span>
      <span className={`font-mono font-bold ${color}`}>{value}</span>
    </div>
  );
}

function LogFeed({ events }: { events: string[] }) {
  return (
    <div className="bg-zinc-950 border-t border-zinc-800 h-32 overflow-y-auto px-4 py-2">
      {[...events].reverse().map((e, i) => (
        <p key={i} className={`text-xs font-mono ${i === 0 ? 'text-white' : 'text-zinc-500'}`}>{e}</p>
      ))}
    </div>
  );
}

function ResultScreen({
  cash, netWorth, income, expenses, season, intelligence, onRestart,
}: {
  cash: number;
  netWorth: number;
  income: number;
  expenses: number;
  season: SeasonState;
  intelligence: IntelligenceState;
  onRestart: () => void;
}) {
  const cashflow = income - expenses;
  const won = cashflow > 0 && netWorth > 100_000;

  return (
    <div className="flex-1 flex flex-col items-center justify-center bg-zinc-950 text-white p-8 gap-6">
      <div className={`text-5xl font-black tracking-tight ${won ? 'text-emerald-400' : 'text-red-400'}`}>
        {won ? 'üèÜ FREEDOM UNLOCKED' : 'üíÄ WIPE'}
      </div>
      <p className="text-zinc-400 text-lg">
        {won ? 'Passive income exceeds expenses. You are free.' : 'You ran out of time or capital.'}
      </p>

      <div className="grid grid-cols-2 md:grid-cols-3 gap-4 text-center max-w-4xl w-full">
        {[
          ['Final Cash', fmtMoney(cash), cash > 0 ? 'text-emerald-400' : 'text-red-400'],
          ['Net Worth', fmtMoney(netWorth), 'text-white'],
          ['Monthly Income', fmtMoney(income), 'text-emerald-400'],
          ['Cashflow', `${cashflow >= 0 ? '+' : ''}${fmtMoney(cashflow)}`, cashflow >= 0 ? 'text-emerald-400' : 'text-red-400'],
          ['Battle Pass Tier', `T${season.passTier}`, 'text-indigo-300'],
          ['AI Alpha', fmtPct01(intelligence.alpha), 'text-cyan-300'],
        ].map(([label, val, color]) => (
          <div key={label as string} className="bg-zinc-900 rounded-xl p-4 border border-zinc-800">
            <p className="text-zinc-500 text-xs uppercase tracking-wide mb-1">{label}</p>
            <p className={`font-mono font-bold text-xl ${color}`}>{val}</p>
          </div>
        ))}
      </div>

      <button
        onClick={onRestart}
        className="mt-4 px-8 py-3 bg-indigo-600 hover:bg-indigo-500 rounded-xl font-bold text-lg transition-colors"
      >
        Play Again
      </button>
    </div>
  );
}

function MechanicsPanel({
  catalog,
  runtime,
  filter,
  setFilter,
  search,
  setSearch,
  selectedId,
  setSelectedId,
}: {
  catalog: MechanicDef[];
  runtime: Record<string, MechanicRuntimeState>;
  filter: MechanicsFilter;
  setFilter: (f: MechanicsFilter) => void;
  search: string;
  setSearch: (v: string) => void;
  selectedId: string | null;
  setSelectedId: (v: string | null) => void;
}) {
  const rows = useMemo(() => {
    const q = search.trim().toLowerCase();
    return catalog.filter((m) => {
      if (filter !== 'all' && m.kind !== filter) return false;
      if (!q) return true;
      return m.id.toLowerCase().includes(q)
        || m.title.toLowerCase().includes(q)
        || m.family.includes(q)
        || m.keywordTags.some((k) => k.includes(q));
    });
  }, [catalog, filter, search]);

  const selected = selectedId ? catalog.find((c) => c.id === selectedId) : rows[0];
  const selectedRuntime = selected ? runtime[selected.id] : undefined;

  return (
    <div className="grid grid-cols-1 xl:grid-cols-[1.2fr_0.8fr] gap-4">
      <div className="bg-zinc-900 border border-zinc-800 rounded-xl overflow-hidden">
        <div className="p-3 border-b border-zinc-800 flex flex-wrap gap-2 items-center">
          <div className="font-bold text-sm">Mechanics Registry (300)</div>
          <div className="ml-auto flex gap-2">
            {(['all', 'core', 'ml'] as const).map((f) => (
              <button
                key={f}
                onClick={() => setFilter(f)}
                className={`px-2 py-1 rounded text-xs border ${filter === f ? 'bg-indigo-600 border-indigo-500 text-white' : 'bg-zinc-800 border-zinc-700 text-zinc-300'}`}
              >
                {f.toUpperCase()}
              </button>
            ))}
          </div>
          <input
            value={search}
            onChange={(e) => setSearch(e.target.value)}
            placeholder="Search MID / title / family..."
            className="w-full mt-2 bg-zinc-950 border border-zinc-800 rounded px-2 py-1 text-xs text-zinc-200 outline-none"
          />
        </div>

        <div className="max-h-[320px] overflow-auto">
          <table className="w-full text-xs">
            <thead className="sticky top-0 bg-zinc-950 text-zinc-400">
              <tr>
                <th className="text-left p-2">ID</th>
                <th className="text-left p-2">Title</th>
                <th className="text-left p-2">Family</th>
                <th className="text-left p-2">Type</th>
                <th className="text-right p-2">Act</th>
                <th className="text-right p-2">Heat</th>
              </tr>
            </thead>
            <tbody>
              {rows.slice(0, 300).map((m) => {
                const r = runtime[m.id];
                const active = (r?.lastTick ?? -1) >= 0;
                return (
                  <tr
                    key={m.id}
                    onClick={() => setSelectedId(m.id)}
                    className={`border-t border-zinc-800 cursor-pointer ${selectedId === m.id ? 'bg-zinc-800/70' : 'hover:bg-zinc-800/40'}`}
                  >
                    <td className="p-2 font-mono text-zinc-200">{m.id}</td>
                    <td className="p-2 text-zinc-300">{m.title}</td>
                    <td className="p-2"><span className="px-1.5 py-0.5 rounded bg-zinc-800 text-zinc-300">{m.family}</span></td>
                    <td className="p-2">
                      <span className={`px-1.5 py-0.5 rounded ${m.kind === 'core' ? 'bg-indigo-900/50 text-indigo-300' : 'bg-cyan-900/50 text-cyan-300'}`}>
                        {m.kind.toUpperCase()}
                      </span>
                    </td>
                    <td className="p-2 text-right font-mono text-zinc-300">{r?.activations ?? 0}</td>
                    <td className={`p-2 text-right font-mono ${active ? 'text-emerald-300' : 'text-zinc-500'}`}>{(r?.heat ?? 0).toFixed(2)}</td>
                  </tr>
                );
              })}
            </tbody>
          </table>
        </div>
      </div>

      <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-4">
        <div className="text-sm font-bold mb-3">Mechanic Inspector</div>
        {!selected ? (
          <div className="text-zinc-500 text-sm">Select a mechanic.</div>
        ) : (
          <div className="space-y-3 text-xs">
            <div>
              <div className="text-zinc-500 uppercase">ID</div>
              <div className="font-mono text-zinc-100">{selected.id}</div>
            </div>
            <div>
              <div className="text-zinc-500 uppercase">Title</div>
              <div className="text-zinc-100">{selected.title}</div>
            </div>
            <div className="grid grid-cols-2 gap-3">
              <div>
                <div className="text-zinc-500 uppercase">Kind</div>
                <div className="text-zinc-100">{selected.kind}</div>
              </div>
              <div>
                <div className="text-zinc-500 uppercase">Family</div>
                <div className="text-zinc-100">{selected.family}</div>
              </div>
              <div>
                <div className="text-zinc-500 uppercase">Pair</div>
                <div className="font-mono text-zinc-100">{selected.pairId || '‚Äî'}</div>
              </div>
              <div>
                <div className="text-zinc-500 uppercase">Weight</div>
                <div className="font-mono text-zinc-100">{selected.weight.toFixed(2)}</div>
              </div>
            </div>
            <div>
              <div className="text-zinc-500 uppercase">Keywords</div>
              <div className="flex flex-wrap gap-1 mt-1">
                {selected.keywordTags.map((k) => (
                  <span key={k} className="px-1.5 py-0.5 rounded bg-zinc-800 text-zinc-300">{k}</span>
                ))}
              </div>
            </div>
            <div className="border-t border-zinc-800 pt-3">
              <div className="text-zinc-500 uppercase mb-2">Runtime State</div>
              <div className="grid grid-cols-2 gap-2 font-mono">
                <div className="bg-zinc-950 rounded p-2">enabled: {String(selectedRuntime?.enabled ?? false)}</div>
                <div className="bg-zinc-950 rounded p-2">act: {selectedRuntime?.activations ?? 0}</div>
                <div className="bg-zinc-950 rounded p-2">lastTick: {selectedRuntime?.lastTick ?? -1}</div>
                <div className="bg-zinc-950 rounded p-2">heat: {(selectedRuntime?.heat ?? 0).toFixed(3)}</div>
                <div className="bg-zinc-950 rounded p-2">conf: {(selectedRuntime?.confidence ?? 0).toFixed(3)}</div>
                <div className="bg-zinc-950 rounded p-2">signal: {(selectedRuntime?.signal ?? 0).toFixed(3)}</div>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

// ‚îÄ‚îÄ‚îÄ App ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

export default function App() {
  const catalog = useMemo(() => buildCatalog(), []);
  const coreCatalog = useMemo(() => catalog.filter((m) => m.kind === 'core'), [catalog]);
  const mlCatalog = useMemo(() => catalog.filter((m) => m.kind === 'ml'), [catalog]);
  const deckPool = useMemo(() => buildGeneratedDeck(coreCatalog), [coreCatalog]);

  const rngRef = useRef<() => number>(() => Math.random());
  const seedRef = useRef<number>(0);

  const [screen, setScreen] = useState<Screen>('landing');
  const [cash, setCash] = useState(STARTING_CASH);
  const [income, setIncome] = useState(STARTING_INCOME);
  const [expenses, setExpenses] = useState(STARTING_EXPENSES);
  const [netWorth, setNetWorth] = useState(STARTING_CASH);
  const [shields, setShields] = useState(0);
  const [shieldConsuming, setShieldConsuming] = useState(false);
  const [tick, setTick] = useState(0);
  const [hand, setHand] = useState<Card[]>([]);
  const [events, setEvents] = useState<string[]>([]);
  const [equityHistory, setEquityHistory] = useState<number[]>([STARTING_CASH]);
  const [freezeTicks, setFreezeTicks] = useState(0);

  const [runMode, setRunMode] = useState<RunMode>('solo');
  const [regime, setRegime] = useState<MarketRegime>('Stable');
  const [mechanicsFilter, setMechanicsFilter] = useState<MechanicsFilter>('all');
  const [mechanicsSearch, setMechanicsSearch] = useState('');
  const [selectedMechanicId, setSelectedMechanicId] = useState<string | null>('M01');

  const [runtime, setRuntime] = useState<Record<string, MechanicRuntimeState>>(() => initRuntime(catalog));
  const [telemetry, setTelemetry] = useState<TelemetryEnvelopeV2[]>([]);

  const [intelligence, setIntelligence] = useState<IntelligenceState>({
    alpha: 0.45,
    risk: 0.35,
    volatility: 0.30,
    antiCheat: 0.50,
    personalization: 0.40,
    rewardFit: 0.45,
    recommendationPower: 0.42,
    churnRisk: 0.28,
    momentum: 0.33,
  });

  const [season, setSeason] = useState<SeasonState>({
    xp: 0,
    passTier: 1,
    dominionControl: 0,
    nodePressure: 0,
    winStreak: 0,
    battlePassLevel: 1,
    rewardsPending: 0,
  });

  const log = useCallback((msg: string) => {
    setEvents((prev) => [...prev.slice(-(MAX_LOG - 1)), `[T${tick}] ${msg}`]);
  }, [tick]);

  const emitTelemetry = useCallback((type: string, payload: TelemetryEnvelopeV2['payload']) => {
    setTelemetry((prev) => [...prev.slice(-299), { tick, type, payload }]);
  }, [tick]);

  const touchMechanic = useCallback((id: string, signal = 0.12) => {
    setRuntime((prev) => {
      const current = prev[id];
      if (!current) return prev;
      return {
        ...prev,
        [id]: {
          ...current,
          activations: current.activations + 1,
          lastTick: tick,
          heat: clamp(current.heat + 0.12 + signal * 0.25, 0, 5),
          confidence: clamp(current.confidence + 0.01 + signal * 0.05, 0.08, 0.99),
          signal: clamp(current.signal + signal, -3, 3),
        },
      };
    });
  }, [tick]);

  const touchFamily = useCallback((family: MechanicFamily, baseSignal = 0.10) => {
    const corePick = coreCatalog.find((m) => m.family === family);
    const mlPick = mlCatalog.find((m) => m.family === family) || mlCatalog[idNum(corePick?.id || 'M01') - 1] || mlCatalog[0];
    if (corePick) touchMechanic(corePick.id, baseSignal);
    if (mlPick) touchMechanic(mlPick.id, baseSignal + 0.04);
  }, [coreCatalog, mlCatalog, touchMechanic]);

  const activeMechanics = useMemo(
    () => Object.values(runtime).filter((r) => r.enabled).length,
    [runtime]
  );

  // Keep pass tier / level derived from XP
  useEffect(() => {
    setSeason((prev) => {
      const tier = Math.max(1, Math.floor(prev.xp / 100) + 1);
      if (tier === prev.passTier && tier === prev.battlePassLevel) return prev;
      return { ...prev, passTier: tier, battlePassLevel: tier };
    });
  }, [season.xp]);

  // Tick engine
  useEffect(() => {
    if (screen !== 'run') return;
    if (tick >= RUN_TICKS) {
      setScreen('result');
      return;
    }

    const timer = setTimeout(() => {
      setTick((t) => t + 1);

      // Runtime decay (all 300 mechanics represented in state)
      setRuntime((prev) => decayRuntime(prev));

      // ML layer inference loop (companion mechanics influence global behavior)
      setIntelligence((prev) => {
        const cashflow = income - expenses;
        const alpha = clamp(prev.alpha + (cashflow > 0 ? 0.004 : -0.003) + (season.winStreak > 0 ? 0.002 : 0) + (regime === 'Expansion' ? 0.002 : regime === 'Panic' ? -0.004 : 0), 0.05, 0.99);
        const risk = clamp(prev.risk + (cash < 10_000 ? 0.006 : -0.002) + (regime === 'Panic' ? 0.005 : 0) - (shields > 0 ? 0.002 : 0), 0.02, 0.99);
        const volatility = clamp(prev.volatility + (regime === 'Compression' ? 0.004 : regime === 'Euphoria' ? 0.005 : -0.001), 0.05, 0.99);
        const antiCheat = clamp(prev.antiCheat + 0.001 - (runMode === 'asymmetric-pvp' ? 0.0005 : 0), 0.10, 0.99);
        const personalization = clamp(prev.personalization + 0.002, 0.10, 0.99);
        const rewardFit = clamp(prev.rewardFit + (season.xp > 0 ? 0.002 : 0.001), 0.10, 0.99);
        const recommendationPower = clamp(prev.recommendationPower + 0.002, 0.10, 0.99);
        const churnRisk = clamp(prev.churnRisk + (cashflow < 0 ? 0.004 : -0.003) + (freezeTicks > 0 ? 0.002 : 0), 0.02, 0.99);
        const momentum = clamp(prev.momentum + (cashflow > 0 ? 0.005 : -0.004), 0.02, 0.99);
        return { alpha, risk, volatility, antiCheat, personalization, rewardFit, recommendationPower, churnRisk, momentum };
      });

      // Light-weight mechanic pulses each tick (representing background systems)
      const pulseA = coreCatalog[tick % coreCatalog.length];
      const pulseB = mlCatalog[tick % mlCatalog.length];
      if (pulseA) touchMechanic(pulseA.id, 0.05);
      if (pulseB) touchMechanic(pulseB.id, 0.07);

      if (tick % 10 === 0) {
        emitTelemetry('runtime.pulse', {
          activeMechanics,
          cash,
          income,
          expenses,
          netWorth,
          alpha: Number(intelligence.alpha.toFixed(3)),
          risk: Number(intelligence.risk.toFixed(3)),
        });
        touchFamily('telemetry', 0.08);
      }

      if (freezeTicks > 0) {
        setFreezeTicks((v) => Math.max(0, v - 1));
      }

      // Monthly settlement
      if (tick % MONTH_TICKS === 0) {
        const cashflow = income - expenses;
        const mlCashflowMod = 1 + (intelligence.alpha - intelligence.risk) * 0.04;
        const settlement = Math.round(cashflow * mlCashflowMod);

        setCash((c) => {
          const next = c + settlement;
          if (next <= 0 && shields === 0) {
            setScreen('bankrupt');
            return 0;
          }
          if (next <= 0 && shields > 0) {
            setShields((s) => s - 1);
            setShieldConsuming(true);
            setTimeout(() => setShieldConsuming(false), 400);
            log('üõ°Ô∏è Shield absorbed bankruptcy!');
            emitTelemetry('shield.proc', { cashBefore: c, settlement, shields });
            touchFamily('risk', 0.20);
            return 5000;
          }
          return next;
        });

        setNetWorth((nw) => nw + settlement);
        setEquityHistory((h) => [...h.slice(-(MAX_EQUITY_POINTS - 1)), netWorth + settlement]);
        setSeason((prev) => ({
          ...prev,
          xp: prev.xp + Math.max(5, Math.round(Math.max(0, settlement) / 500)),
          dominionControl: clamp(prev.dominionControl + (settlement > 0 ? 1 : -1), 0, 9999),
          nodePressure: clamp(prev.nodePressure + (settlement < 0 ? 2 : -1), 0, 9999),
          rewardsPending: prev.rewardsPending + (settlement > 0 ? 1 : 0),
          winStreak: settlement > 0 ? prev.winStreak + 1 : 0,
        }));

        emitTelemetry('economy.monthly_settlement', {
          settlement,
          cashflow,
          mlCashflowMod: Number(mlCashflowMod.toFixed(3)),
          cash,
          income,
          expenses,
          netWorth,
        });

        touchFamily('economy', 0.18);
        touchFamily('ai', 0.14);
      }

      // Draw cadence (ML recommendation engine shapes hazard/opportunity mix)
      if (tick % DRAW_TICKS === 0 && hand.length < MAX_HAND && freezeTicks === 0) {
        const draws = drawRandomCards(deckPool, 1, rngRef.current);
        const recBias = intelligence.recommendationPower - intelligence.risk;
        const card = draws[0];

        // Soft reroll toward non-hazard when recommendation power is high
        let finalCard = card;
        if (card && card.type === ('FUBAR' as DeckType) && recBias > 0.20 && rngRef.current() < 0.55) {
          const rerolls = drawRandomCards(deckPool.filter((c) => c.type !== ('FUBAR' as DeckType)), 1, rngRef.current);
          if (rerolls[0]) {
            finalCard = rerolls[0];
            touchFamily('ai', 0.15);
            log(`üß† ML rerouted draw away from hazard ‚Üí ${finalCard.name}`);
          }
        }

        if (finalCard) {
          setHand((h) => [...h, finalCard]);
          log(`üì¨ Drew: ${finalCard.name}`);
          emitTelemetry('cards.draw', { cardId: finalCard.id, cardType: finalCard.type, handSize: hand.length + 1 });
          touchFamily('cards', 0.16);
        }
      }

      // Macro events / market regime
      if (tick % 90 === 0 && tick > 0) {
        const macroEvents: MacroEvent[] = [
          {
            id: 'bull',
            label: 'üìà Bull run! Income assets +10%',
            apply: () => {
              setIncome((i) => Math.round(i * 1.1));
              setRegime('Expansion');
              touchFamily('market', 0.22);
            },
          },
          {
            id: 'recession',
            label: 'üìâ Recession hits. Expenses +12%',
            apply: () => {
              setExpenses((e) => Math.round(e * 1.12));
              setRegime('Compression');
              touchFamily('risk', 0.24);
            },
          },
          {
            id: 'rally',
            label: 'üíπ Market rally. Net worth +8%',
            apply: () => {
              setNetWorth((nw) => Math.round(nw * 1.08));
              setRegime('Euphoria');
              touchFamily('market', 0.20);
            },
          },
          {
            id: 'bill',
            label: 'üî• Unexpected bill. -$2,000 cash.',
            apply: () => {
              setCash((c) => c - 2000);
              setRegime('Panic');
              touchFamily('risk', 0.22);
            },
          },
          {
            id: 'integrity',
            label: 'üõ°Ô∏è Integrity sweep grants shield.',
            apply: () => {
              setShields((s) => s + 1);
              setRegime('Stable');
              touchFamily('anti_cheat', 0.25);
            },
          },
        ];

        const ev = macroEvents[Math.floor(rngRef.current() * macroEvents.length)];
        ev.apply();
        log(ev.label);
        emitTelemetry('macro.event', { id: ev.id, label: ev.label, regime });
      }

      // Season / Dominion pulse
      if (tick % 60 === 0 && tick > 0) {
        setSeason((prev) => ({
          ...prev,
          xp: prev.xp + 12,
          dominionControl: prev.dominionControl + 1,
          nodePressure: clamp(prev.nodePressure + (prev.dominionControl % 3 === 0 ? 1 : -1), 0, 9999),
        }));
        touchFamily('season', 0.18);
        emitTelemetry('season.pulse', { xp: season.xp, tier: season.passTier, dominion: season.dominionControl });
      }

      // PvP ghost pulse (simulation-facing hook)
      if (tick % 75 === 0 && tick > 0 && runMode !== 'solo') {
        const delta = Math.round((intelligence.alpha - intelligence.risk) * 12);
        setSeason((prev) => ({ ...prev, winStreak: Math.max(0, prev.winStreak + (delta >= 0 ? 1 : -1)) }));
        touchFamily('pvp', 0.17);
        emitTelemetry('pvp.ghost_tick', { mode: runMode, edgeDelta: delta });
      }

      // Anti-cheat heartbeat (always represented)
      if (tick % 45 === 0) {
        touchFamily('anti_cheat', 0.12);
        emitTelemetry('integrity.heartbeat', { antiCheat: Number(intelligence.antiCheat.toFixed(3)) });
      }
    }, TICK_MS);

    return () => clearTimeout(timer);
  }, [
    screen,
    tick,
    income,
    expenses,
    netWorth,
    shields,
    hand.length,
    deckPool,
    cash,
    season,
    regime,
    intelligence,
    runMode,
    freezeTicks,
    activeMechanics,
    coreCatalog,
    mlCatalog,
    log,
    emitTelemetry,
    touchMechanic,
    touchFamily,
  ]);

  const handlePlayCard = useCallback((cardId: string) => {
    const card = hand.find((c) => c.id === cardId);
    if (!card) return;

    // Don't remove before affordability check
    if ((card.type === 'OPPORTUNITY' || card.type === 'IPA') && cash < (card.energyCost ?? 0)) {
      log(`‚ùå Can't afford ${card.name}`);
      emitTelemetry('cards.play_rejected', { cardId: card.id, reason: 'insufficient_cash', cash });
      touchFamily('economy', 0.10);
      return;
    }

    setHand((h) => h.filter((c) => c.id !== cardId));

    const lower = card.name.toLowerCase();
    const derivedIdMatch = card.id.match(/gen-(m\d+[a-z]?)/i);
    const mechId = derivedIdMatch ? derivedIdMatch[1].toUpperCase() : null;
    const mech = mechId ? catalog.find((m) => m.id.toLowerCase() === mechId.toLowerCase()) : undefined;

    if (card.type === 'OPPORTUNITY' || card.type === 'IPA') {
      const spend = card.energyCost ?? 0;
      setCash((c) => c - spend);
      if (card.cashflowMonthly != null) setIncome((i) => i + card.cashflowMonthly!);
      if (card.value != null) setNetWorth((nw) => nw + card.value!);

      // Mechanic-family-driven outcomes
      if (mech?.family === 'season') {
        setSeason((prev) => ({ ...prev, xp: prev.xp + 15, dominionControl: prev.dominionControl + 2, rewardsPending: prev.rewardsPending + 1 }));
      } else if (mech?.family === 'progression') {
        setSeason((prev) => ({ ...prev, xp: prev.xp + 10 }));
      } else if (mech?.family === 'social') {
        setShields((s) => s + 1);
      } else if (mech?.family === 'pvp') {
        setSeason((prev) => ({ ...prev, winStreak: prev.winStreak + 1, xp: prev.xp + 8 }));
      } else if (mech?.family === 'cards') {
        const bonusDraw = drawRandomCards(deckPool.filter((c) => c.id !== card.id), 1, rngRef.current)[0];
        if (bonusDraw) {
          setHand((h) => (h.length < MAX_HAND ? [...h, bonusDraw] : h));
          log(`üÉè Deck engine bonus draw ‚Üí ${bonusDraw.name}`);
        }
      } else if (mech?.family === 'replay' || mech?.family === 'telemetry' || mech?.family === 'ops') {
        emitTelemetry('system.card_play', { cardId: card.id, family: mech.family, incomeBoost: card.cashflowMonthly ?? 0 });
      }

      if (mechId) touchMechanic(mechId, 0.22);
      if (mech?.pairId) touchMechanic(mech.pairId, 0.18);
      touchFamily(mech?.family ?? 'economy', 0.16);

      log(`‚úÖ Played: ${card.name}${card.cashflowMonthly ? ` ‚Üí +${fmtMoney(card.cashflowMonthly)}/mo` : ''}`);
      emitTelemetry('cards.play', {
        cardId: card.id,
        cardType: card.type,
        cost: spend,
        cashflowMonthly: card.cashflowMonthly ?? 0,
        family: mech?.family ?? 'unknown',
      });

      setSeason((prev) => ({ ...prev, xp: prev.xp + 5 }));
    } else if (card.type === 'FUBAR') {
      if (shields > 0) {
        setShields((s) => s - 1);
        log(`üõ°Ô∏è Shield blocked: ${card.name}`);
        emitTelemetry('cards.fubar_blocked', { cardId: card.id, shieldCount: shields });
      } else {
        const hit = card.cashImpact ?? -1500;
        const riskScale = 1 + intelligence.risk * 0.4 + intelligence.volatility * 0.2;
        const adjustedHit = Math.round(hit * riskScale);
        setCash((c) => Math.max(0, c + adjustedHit));
        setSeason((prev) => ({ ...prev, nodePressure: prev.nodePressure + 2, winStreak: 0 }));
        log(`üí• FUBAR hit: ${card.name} ‚Üí ${fmtMoney(adjustedHit)}`);
        emitTelemetry('cards.fubar_hit', { cardId: card.id, cashImpact: adjustedHit, riskScale: Number(riskScale.toFixed(3)) });
      }
      if (mechId) touchMechanic(mechId, 0.25);
      if (mech?.pairId) touchMechanic(mech.pairId, 0.22);
      touchFamily('risk', 0.20);
    } else if (card.type === 'PRIVILEGED') {
      const v = card.value ?? 0;
      setNetWorth((nw) => nw + v);
      setSeason((prev) => ({ ...prev, xp: prev.xp + 10, dominionControl: prev.dominionControl + 3, rewardsPending: prev.rewardsPending + 1 }));
      log(`‚≠ê Privilege activated: ${card.name} ‚Üí +${fmtMoney(v)} value`);
      emitTelemetry('cards.privileged', { cardId: card.id, value: v });
      if (mechId) touchMechanic(mechId, 0.20);
      if (mech?.pairId) touchMechanic(mech.pairId, 0.20);
      touchFamily(mech?.family ?? 'season', 0.18);
    } else if (card.type === 'MISSED_OPPORTUNITY') {
      const lost = card.turnsLost ?? 1;
      setFreezeTicks((f) => Math.max(f, lost));
      setSeason((prev) => ({ ...prev, nodePressure: prev.nodePressure + 1, winStreak: 0 }));
      log(`üò¨ Missed: ${card.name} ‚Äî action freeze ${lost} ticks`);
      emitTelemetry('cards.missed', { cardId: card.id, turnsLost: lost });
      if (mechId) touchMechanic(mechId, 0.16);
      if (mech?.pairId) touchMechanic(mech.pairId, 0.16);
      touchFamily('progression', 0.12);
    } else if (card.type === 'SO') {
      const roll = rngRef.current();
      if (roll < 0.34) {
        setShields((s) => s + 1);
        log(`üöß Obstacle solved: ${card.name} ‚Üí +1 shield`);
      } else if (roll < 0.67) {
        setSeason((prev) => ({ ...prev, xp: prev.xp + 7 }));
        log(`üöß Obstacle solved: ${card.name} ‚Üí +XP`);
      } else {
        setCash((c) => c + 1000);
        log(`üöß Obstacle solved: ${card.name} ‚Üí +${fmtMoney(1000)}`);
      }
      emitTelemetry('cards.obstacle', { cardId: card.id });
      if (mechId) touchMechanic(mechId, 0.14);
      if (mech?.pairId) touchMechanic(mech.pairId, 0.14);
      touchFamily(mech?.family ?? 'ops', 0.12);
    }
  }, [hand, cash, shields, catalog, deckPool, intelligence, log, emitTelemetry, touchMechanic, touchFamily]);

  const startRun = useCallback(() => {
    const seed = randomSeed();
    seedRef.current = seed;
    rngRef.current = mulberry32(seed);

    setCash(STARTING_CASH);
    setIncome(STARTING_INCOME);
    setExpenses(STARTING_EXPENSES);
    setNetWorth(STARTING_CASH);
    setShields(0);
    setTick(0);
    setFreezeTicks(0);

    setRuntime(initRuntime(catalog));
    setTelemetry([]);
    setIntelligence({
      alpha: 0.45,
      risk: 0.35,
      volatility: 0.30,
      antiCheat: 0.50,
      personalization: 0.40,
      rewardFit: 0.45,
      recommendationPower: 0.42,
      churnRisk: 0.28,
      momentum: 0.33,
    });
    setSeason({
      xp: 0,
      passTier: 1,
      dominionControl: 0,
      nodePressure: 0,
      winStreak: 0,
      battlePassLevel: 1,
      rewardsPending: 0,
    });
    setRegime('Stable');
    setHand(drawRandomCards(deckPool, 4, rngRef.current));
    setEvents([`üéÆ Run started (seed=${seed}). 300 mechanics + 150 ML companions online.`]);
    setEquityHistory([STARTING_CASH]);
    setSelectedMechanicId('M01');
    setScreen('run');
  }, [catalog, deckPool]);

  const topMechanics = useMemo(() => {
    return [...catalog]
      .sort((a, b) => (runtime[b.id]?.activations ?? 0) - (runtime[a.id]?.activations ?? 0))
      .slice(0, 5);
  }, [catalog, runtime]);

  // ‚îÄ‚îÄ Landing ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (screen === 'landing') {
    return (
      <div className="min-h-screen bg-zinc-950 text-white flex flex-col items-center justify-center gap-8 p-8">
        <div className="text-center">
          <h1 className="text-5xl font-black tracking-tight text-white mb-2">
            POINT <span className="text-indigo-400">ZERO ONE</span>
          </h1>
          <p className="text-zinc-400 text-lg max-w-3xl">
            Financial roguelike + systems simulator. All 150 core mechanics and all 150 ML/DL companions are loaded into a live runtime registry,
            reflected as deck logic, market behavior, risk, progression, season dominion, telemetry, and anti-cheat pulses.
          </p>
        </div>

        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-center text-sm max-w-5xl w-full">
          {[
            ['üß†', '300 Mechanics', '150 core + 150 ML/DL companions'],
            ['üÉè', 'Generated Deck', 'Core mechanics become playable cards'],
            ['üì°', 'TelemetryV2', 'Runtime pulses + settlements + events'],
            ['üèõÔ∏è', 'Season Dominion', 'XP, pass tier, node pressure, control'],
            ['‚öîÔ∏è', 'PvP Hooks', 'Ghost/asymmetric pulse lanes'],
            ['üõ°Ô∏è', 'Integrity Layer', 'Anti-cheat heartbeat & shield events'],
            ['üîÅ', 'Deterministic Seeds', 'Replay-ready run seed'],
            ['üíÄ', 'Permadeath Pressure', 'Bankruptcy + time bounded run'],
          ].map(([icon, title, sub]) => (
            <div key={title} className="bg-zinc-900 rounded-xl p-4 border border-zinc-800">
              <div className="text-2xl mb-1">{icon}</div>
              <div className="font-bold text-white">{title}</div>
              <div className="text-zinc-500 text-xs">{sub}</div>
            </div>
          ))}
        </div>

        <div className="flex flex-wrap items-center justify-center gap-3">
          {(['solo', 'asymmetric-pvp', 'co-op', 'ghost'] as const).map((mode) => (
            <button
              key={mode}
              onClick={() => setRunMode(mode)}
              className={`px-3 py-2 rounded-lg text-sm border ${runMode === mode ? 'bg-indigo-600 border-indigo-500 text-white' : 'bg-zinc-900 border-zinc-800 text-zinc-300'}`}
            >
              {mode}
            </button>
          ))}
        </div>

        <button
          onClick={startRun}
          className="px-12 py-4 bg-indigo-600 hover:bg-indigo-500 rounded-2xl font-black text-xl tracking-wide transition-all hover:scale-105 active:scale-95 shadow-lg shadow-indigo-900"
        >
          START RUN
        </button>

        <p className="text-zinc-600 text-xs">
          Goal: passive income &gt; expenses before 720 ticks ¬∑ Seeded deterministic runtime ¬∑ 300 mechanics represented
        </p>
      </div>
    );
  }

  // ‚îÄ‚îÄ Bankrupt ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (screen === 'bankrupt') {
    return (
      <BankruptcyScreen
        seed={seedRef.current}
        tick={tick}
        regime={regime}
        intelligence={intelligence}
        season={season}
        events={events}
        equityHistory={equityHistory}
        onPlayAgain={() => setScreen('landing')}
      />
    );
  }

  // ‚îÄ‚îÄ Result ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  if (screen === 'result') {
    return (
      <div className="min-h-screen bg-zinc-950 flex flex-col gap-6 items-center justify-start p-6 overflow-auto">
        <ResultScreen
          cash={cash}
          netWorth={netWorth}
          income={income}
          expenses={expenses}
          season={season}
          intelligence={intelligence}
          onRestart={() => setScreen('landing')}
        />
        <div className="w-full max-w-xl">
          <ProofCard
            seed={seedRef.current}
            tick={tick}
            totalTicks={RUN_TICKS}
            cash={cash}
            netWorth={netWorth}
            income={income}
            expenses={expenses}
            intelligence={intelligence}
            season={season}
            regime={regime}
            topEvents={events}
          />
        </div>
      </div>
    );
  }

  // ‚îÄ‚îÄ Run ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  return (
    <div className="min-h-screen bg-zinc-950 flex flex-col text-white">
      <HUD
        cash={cash}
        income={income}
        expenses={expenses}
        tick={tick}
        shields={shields}
        netWorth={netWorth}
        equityHistory={equityHistory}
        regime={regime}
        intelligence={intelligence}
        season={season}
        runMode={runMode}
        activeMechanics={activeMechanics}
        telemetryCount={telemetry.length}
        freezeTicks={freezeTicks}
      />

      <div className="flex-1 overflow-auto p-4 space-y-4">
        <div className="grid grid-cols-1 2xl:grid-cols-[1.2fr_0.8fr] gap-4">
          <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-3">
            <div className="flex items-center justify-between mb-2">
              <div className="flex items-center gap-3">
                <div className="font-bold text-sm">Playable Hand</div>
                <ShieldIcons count={shields} consuming={shieldConsuming} />
              </div>
              <div className="text-xs text-zinc-500">Seed {seedRef.current || '‚Äî'} ¬∑ Tick {tick}/{RUN_TICKS}</div>
            </div>
            <CardHand cards={hand} playerEnergy={cash} onPlayCard={handlePlayCard} onCardHover={() => {}} />
          </div>

          <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-4">
            <div className="font-bold text-sm mb-3">Run Intelligence / Season Snapshot</div>
            <div className="grid grid-cols-2 gap-2 text-xs">
              {[
                ['Alpha', fmtPct01(intelligence.alpha)],
                ['Risk', fmtPct01(intelligence.risk)],
                ['Volatility', fmtPct01(intelligence.volatility)],
                ['Anti-Cheat', fmtPct01(intelligence.antiCheat)],
                ['Personalization', fmtPct01(intelligence.personalization)],
                ['Reward Fit', fmtPct01(intelligence.rewardFit)],
                ['Reco Power', fmtPct01(intelligence.recommendationPower)],
                ['Churn Risk', fmtPct01(intelligence.churnRisk)],
                ['Momentum', fmtPct01(intelligence.momentum)],
                ['XP', `${season.xp}`],
                ['Pass Tier', `T${season.passTier}`],
                ['Dominion', `${season.dominionControl}`],
                ['Node Pressure', `${season.nodePressure}`],
                ['Win Streak', `${season.winStreak}`],
                ['Rewards Pending', `${season.rewardsPending}`],
                ['Freeze', freezeTicks > 0 ? `${freezeTicks} ticks` : '‚Äî'],
              ].map(([label, value]) => (
                <div key={label} className="bg-zinc-950 border border-zinc-800 rounded p-2">
                  <div className="text-zinc-500 uppercase tracking-wide">{label}</div>
                  <div className="font-mono text-zinc-100">{value}</div>
                </div>
              ))}
            </div>

            <div className="mt-4 border-t border-zinc-800 pt-3">
              <div className="text-xs font-bold mb-2">Top Activated Mechanics</div>
              <div className="space-y-1">
                {topMechanics.map((m) => {
                  const r = runtime[m.id];
                  return (
                    <div key={m.id} className="text-xs bg-zinc-950 border border-zinc-800 rounded p-2 flex items-center gap-2">
                      <span className="font-mono text-zinc-300">{m.id}</span>
                      <span className="text-zinc-400 truncate">{m.title}</span>
                      <span className="ml-auto font-mono text-emerald-300">{r?.activations ?? 0}</span>
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
        </div>

        <GameBoard
          equityHistory={equityHistory}
          cash={cash}
          netWorth={netWorth}
          income={income}
          expenses={expenses}
          regime={regime}
          intelligence={intelligence}
          tick={tick}
          totalTicks={RUN_TICKS}
          freezeTicks={freezeTicks}
        />

        <MechanicsPanel
          catalog={catalog}
          runtime={runtime}
          filter={mechanicsFilter}
          setFilter={setMechanicsFilter}
          search={mechanicsSearch}
          setSearch={setMechanicsSearch}
          selectedId={selectedMechanicId}
          setSelectedId={setSelectedMechanicId}
        />

        <div className="bg-zinc-900 border border-zinc-800 rounded-xl p-4">
          <div className="font-bold text-sm mb-2">Recent TelemetryEnvelopeV2 Events</div>
          <div className="max-h-40 overflow-auto space-y-1">
            {[...telemetry].slice(-20).reverse().map((ev, i) => (
              <div key={`${ev.tick}-${ev.type}-${i}`} className="text-xs font-mono bg-zinc-950 border border-zinc-800 rounded p-2">
                <span className="text-zinc-500">T{ev.tick}</span>{' '}
                <span className="text-cyan-300">{ev.type}</span>{' '}
                <span className="text-zinc-400">{JSON.stringify(ev.payload)}</span>
              </div>
            ))}
          </div>
        </div>
      </div>

      <LogFeed events={events} />

      {/* MomentFlash ‚Äî fixed overlay, bottom-right */}
      <div className="fixed bottom-36 right-4 w-80 z-50 pointer-events-auto">
        <MomentFlash events={events} tick={tick} maxVisible={3} />
      </div>
    </div>
  );
}
