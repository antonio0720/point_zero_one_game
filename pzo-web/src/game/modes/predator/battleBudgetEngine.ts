// ═══════════════════════════════════════════════════════════════════════════
// POINT ZERO ONE — game/modes/predator/battleBudgetEngine.ts
// Sprint 4 — Battle Budget System
//
// Battle Budget (BB) is the Predator's attack currency.
// Generated by: card plays, extraction wins, tempo chains.
// Consumed by: extraction attacks, counterplay blocks, psyche pressure.
// Capped per round — forces burst decision cycles over hoarding.
// ═══════════════════════════════════════════════════════════════════════════

import { PREDATOR_CONFIG } from './predatorConfig';

export interface BattleBudgetState {
  current: number;
  roundGenerated: number;
  totalGenerated: number;
  totalSpent: number;
  roundCap: number;
  extractionsFired: number;
  bbDebt: number;           // negative BB = forced pause on attacks
}

export const INITIAL_BB_STATE: BattleBudgetState = {
  current: 0,
  roundGenerated: 0,
  totalGenerated: 0,
  totalSpent: 0,
  roundCap: PREDATOR_CONFIG.bbMaxPerRound,
  extractionsFired: 0,
  bbDebt: 0,
};

// ─── Generation ───────────────────────────────────────────────────────────────

export interface BBGenerationInput {
  cardEnergyCost: number;
  cashflowMonthly: number;
  isTempoChain: boolean;
  tempoMultiplier?: number;
}

export function generateBB(
  input: BBGenerationInput,
  state: BattleBudgetState,
): { amount: number; updatedState: BattleBudgetState } {
  const { cardEnergyCost, cashflowMonthly, isTempoChain, tempoMultiplier = 1.0 } = input;

  const baseGen = Math.round(
    cardEnergyCost * PREDATOR_CONFIG.bbGenerationRate +
    cashflowMonthly * 0.5
  );
  const chainBonus = isTempoChain ? Math.round(baseGen * (tempoMultiplier - 1)) : 0;
  const rawAmount = baseGen + chainBonus;

  // Round cap enforcement
  const headroom = state.roundCap - state.roundGenerated;
  const amount = Math.min(rawAmount, Math.max(0, headroom));

  const updatedState: BattleBudgetState = {
    ...state,
    current: state.current + amount,
    roundGenerated: state.roundGenerated + amount,
    totalGenerated: state.totalGenerated + amount,
  };

  return { amount, updatedState };
}

// ─── Consumption ──────────────────────────────────────────────────────────────

export type BBSpendReason =
  | 'EXTRACTION_FIRE'
  | 'COUNTERPLAY_BLOCK'
  | 'PSYCHE_PRESSURE'
  | 'DECK_CLAIM'
  | 'RIVALRY_AMPLIFIER';

export interface BBSpendResult {
  success: boolean;
  amountSpent: number;
  shortfall: number;
  updatedState: BattleBudgetState;
}

export function spendBB(
  amount: number,
  reason: BBSpendReason,
  state: BattleBudgetState,
): BBSpendResult {
  if (state.current < amount) {
    const shortfall = amount - state.current;
    return {
      success: false,
      amountSpent: 0,
      shortfall,
      updatedState: { ...state, bbDebt: state.bbDebt + shortfall },
    };
  }

  const updatedState: BattleBudgetState = {
    ...state,
    current: state.current - amount,
    totalSpent: state.totalSpent + amount,
    extractionsFired: reason === 'EXTRACTION_FIRE' ? state.extractionsFired + 1 : state.extractionsFired,
  };

  return { success: true, amountSpent: amount, shortfall: 0, updatedState };
}

// ─── Round Reset ──────────────────────────────────────────────────────────────

export function resetBBRound(state: BattleBudgetState): BattleBudgetState {
  return {
    ...state,
    roundGenerated: 0,
    bbDebt: Math.max(0, state.bbDebt - 50), // partial debt forgiveness each round
  };
}

// ─── Derived ──────────────────────────────────────────────────────────────────

export function canFireExtraction(state: BattleBudgetState, extractionCost: number): boolean {
  return state.current >= extractionCost && state.bbDebt === 0;
}

export function bbPressureRatio(state: BattleBudgetState): number {
  if (state.totalGenerated === 0) return 0;
  return parseFloat((state.totalSpent / state.totalGenerated).toFixed(3));
}
